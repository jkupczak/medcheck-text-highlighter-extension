/////// @REF
// - https://stackoverflow.com/questions/11325415/access-iframe-content-from-a-chromes-extension-content-script
// - https://stackoverflow.com/questions/38103534/in-chrome-extension-how-to-send-a-cross-origin-message-from-a-parent-content-sc
// -
// -
// -
///////

/////// TODO
// - I'm not confident that this correctly counts iframes that are inside of iframes. But I'm also not sure that I care.
// -
// -
// -
///////

////////////
//
// Global Variables
//
////////////

  totalCount = 0;

  // Array of strings to find in the document.
  // Eventually this will be generated by grabbing it from chrome.storage.sync
  // Users will be able to add and subtract from this list from options.html
  stringsToFind = [
    {
      toMatch: 'medbridge',
      type: 'string',
      caseSensitive: "i",
      class: ''
    },
    {
      toMatch: 'Change View',
      type: 'string',
      caseSensitive: "",
      class: ''
    }
  ];

////////////
//
// Functions
//
////////////

/**
 * [someFunction description]
 * @param  {[type]} arg1 [description]
 * @param  {[type]} arg2 [description]
 * @return {[type]}      [description]
 */
function createRegex(entry) {

  // If we just want to match a string, escape it first.
  if ( entry.type === "string" ) {
    entry.toMatch = entry.toMatch.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  // return the regex
  return new RegExp(entry.toMatch, "g" + entry.caseSensitive);
}


/**
 * [someFunction description]
 * @param  {[type]} arg1 [description]
 * @param  {[type]} arg2 [description]
 * @return {[type]}      [description]
 */
function inIframe () {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}


/**
 * [someFunction description]
 * @param  {[type]} arg1 [description]
 * @param  {[type]} arg2 [description]
 * @return {[type]}      [description]
 */
function isVisible(el) {

  // Check if the node or a parent node is...
  //  - display: none
  //  - visibility: hidden

  // TODO: Can I check for parents with visibility hidden instead of using getComputedStyle?

  if ( el.offsetParent !== null ) {
    // if its visible then check getComputedStyle as well.
    // we don't want to bother checking getComputedStyle if offsetParent was enough
    return getComputedStyle(el).visibility !== 'hidden';
  } else {
    return false;
  }

}


/**
 * [someFunction description]
 * @param  {[type]} arg1 [description]
 * @param  {[type]} arg2 [description]
 * @return {[type]}      [description]
 */
var updateBadge = function(count) {
  chrome.runtime.sendMessage({updatebadge:true, data:count});
};


/**
 * [someFunction description]
 * @param  {[type]} arg1 [description]
 * @param  {[type]} arg2 [description]
 * @return {[type]}      [description]
 */
var countObject = {};
var processCount = function(source, count, timestamp, url) {

  // Reset count to 0 and then re-add all of our data
  totalCount = 0;

  // Add to our object
  countObject[source] = { count: count, timestamp: timestamp, url: url};

  // console.log( "keys", Object.keys(countObject).length, "iframes", document.querySelectorAll("iframe").length, countObject);

  // verify our counts by looping through the object
  for (var key in countObject) {
    // If its been more than 10 seconds since this entry has been updated, remove it.
    if ( Math.floor((Date.now() - countObject[key].timestamp)/1000) > 5 ) {
      delete countObject[key];
      console.warn("Deleted an item.");
    }
    else {
      totalCount = totalCount + countObject[key].count;
    }

  }

  // Show/hide the count indicator only in the top frame.
  // Any highlights that occur in an iframe should have already sent their data to the parent frame to be counted.
  if ( !inIframe() ) {
    indicator.innerText = totalCount;
    if ( totalCount > 0 ) {
      // Check that our indicator still exists in the DOM.
      // This is a failsafe in case the page we're on is aggressive about rebuilding the DOM and removing our element.
      // If it doesn't have a parent element, that means its gone missing. Re-append it to the body.
      // We technically only need to re-add it if we're going to also SHOW it, so thats why its inside this if statement
      if ( !indicator.parentElement ) {
        document.body.appendChild(indicator);
      }
      indicator.classList.add("active");
    } else {
      indicator.classList.remove("active");
    }

    // Report the count to the background page to update the extension badge
    updateBadge(totalCount);
  }

};


////////////
//
// Listener
//
////////////

// If we're not in an iframe, then we're the parent window.
// So we need to listen for messages sent from the background page.
// The background page is relaying messages sent from the iframes on this page
if ( !inIframe() ) {
  chrome.runtime.onMessage.addListener(function(details) {

    // Send the message we received from the background to our processCount() function.
    processCount(details.sender.frameId, details.message.data, Date.now(), details.sender.url);

  });
}


////////////
//
// Indicator
//
////////////

// This creates the DOM element that holds the visual display of how many matches we've found.
// This only runs once when the parent page is considered idle.
// Only runs in the parent window.
if ( !inIframe() ) {

  var indicator = document.createElement("div");
  indicator.classList.add("medcheck-indicator");
  document.body.appendChild(indicator);

}


////////////
//
// Highlighter
//
////////////

// This function uses the findAndReplaceDOMText library to scan all text nodes and find matches
// When it finds a match, it wraps it in a <span> and gives it a class.
// After it scans the page it counts all <span>s on the page that it created.
// It only counts visible <span>s and then uses the processCount() function if we're in the parent frame
// Otherwise, we're in an iframe and it instead sends the results to the background page.
// We do this because we need to let the parent page know how many <span>s there are.
// Using sendMessage and background page as a middleman allows us to get around cross-origin policies.
// This functions runs once immediately when the page becomes idle, and then again at a specific interval thats set below

var highlight = (function bar() {

  // Loop through every string/regex we want to find in the document
  // All of our strings are held in the stringsToFind array
  stringsToFind.forEach(function (entry, index) {

    // Create Regex
    // Use the info in this entry to create the appropriate regex for our function below.
    var find = createRegex(entry);

    // Classes
    // Add extra classes if we need to
    if ( entry.class !== '' ) {
      wrapClass = "medcheck-text-highlight " + entry.class;
    } else {
      wrapClass = "medcheck-text-highlight";
    }

    findAndReplaceDOMText(document.body, {
      find: find,
      wrap: 'span',
      wrapClass: wrapClass,
      // Prevent this from running on elements that were already checked previously.
      // https://github.com/padolsey/findAndReplaceDOMText/issues/24#issuecomment-61420897
      filterElements: function(node) {
        // Ignore
        //  - <script>
        //  - <style>
        //  - .medcheck-text-highlight
        //  - nodes without a tagName
        return node.tagName && !node.classList.contains("medcheck-text-highlight") && node.tagName !== "SCRIPT" && node.tagName !== "STYLE";
      }
    });
  });


  // Count the total highlights.
  // Only count them if they're display is not 'none' and they are in the viewport.
  var totalHighlights = 0;

  // Count highlights in the parent frame
  let highlights = document.querySelectorAll(".medcheck-text-highlight");
  for (let highlight of highlights) {
    if ( isVisible(highlight) ) {

      totalHighlights++;

    }
  }

  // Push total highlights to the parent frame if this is an iframe
  if ( inIframe() ) {

      // Send a message that contains the total from this frame to the background page
      // The background page will receive this message and send it back to the parent frame
      // We have to do this because we can't guarantee that every iframe will be of the same origin
      chrome.runtime.sendMessage({sendBack:true, data:totalHighlights});

  } else {

    processCount("parent", totalHighlights, Date.now(), document.URL);

  }

  return bar; // self-executing - https://stackoverflow.com/a/10890302/556079
})();

//////////////////////
//
// execute again at 3 second intervals
// Only execute if the document is visible (the tab is active)
//
/////////////////////
setInterval(function(){
  if (!document.hidden) {
    highlight();
  }
}, 3000);

//////////////////////
//
// Visibility Change
// When the page becomes visible, send the current count to the background page.
//
/////////////////////
document.addEventListener("visibilitychange", function() {
  if ( !document.hidden ) {
    updateBadge(totalCount);
  }
});
